# Version Lock + Worktree Protocol — StakTrakr

## Why This Exists

Multiple agents (Claude, Gemini, Codex, Jules) work concurrently on the same local git repo.
Without coordination, two agents can:

1. Compute the same "next version" and produce duplicate/skipped version tags
2. Make conflicting edits to the same files in the shared `dev` branch

This protocol solves both problems: a **version lock** claims the next version number, and a
**git worktree** gives each agent an isolated filesystem to work in.

The actual lock state lives in `devops/version.lock` (gitignored). Worktrees live in
`.claude/worktrees/` (also gitignored).

---

## Full Protocol (10 steps)

### Step 0 — SYNC with remote before starting

Before claiming a version lock or creating a worktree, confirm local `dev` is in sync
with `origin/dev`. A worktree created from a stale HEAD produces PRs that conflict with
or silently drop remote commits that landed while you were offline.

```bash
git fetch origin
git rev-list HEAD..origin/dev --count
```

- **Count is 0:** Proceed to Step 1. ✅
- **Count > 0:** HARD STOP. Show the incoming commits and require a pull:

```bash
git log --oneline HEAD..origin/dev   # show what you'd be missing
git pull origin dev                   # pull, then restart from Step 0
```

Do not proceed until `git rev-list HEAD..origin/dev --count` returns `0`.

### Step 1 — SYNC local dev with origin/dev

Before touching the lock, ensure local `dev` is current:

```bash
git fetch origin
git merge origin/dev --ff-only
```

Resolve any conflicts now, in the main working tree, before the worktree is created.
This guarantees the worktree starts from the freshest possible base.

### Step 2 — READ and PRUNE the lock file

```bash
cat devops/version.lock 2>/dev/null || echo "UNLOCKED"
```

The lock file now uses a **claims array** — multiple agents can hold concurrent claims on
different version numbers.

**Parse the file (or treat as empty if missing/invalid):**

1. Read the `claims` array
2. Remove any entries where `expires_at` < current UTC time (pruning expired claims)
3. Write the pruned file back if any entries were removed

If the file is missing, treat `claims` as `[]`.

### Step 3 — COMPUTE your version

1. Find the highest `version` string in the active (non-expired) claims
2. If no active claims exist, read current `APP_VERSION` from `js/constants.js`
3. Increment the PATCH component by 1 → this is **your version**

Example: active claims hold `3.32.29` and `3.32.30` → your version is `3.32.31`.
Example: no active claims, `APP_VERSION` is `3.32.28` → your version is `3.32.29`.

### Step 4 — APPEND your claim

Add a new entry to the `claims` array and write the file:

```json
{
  "claims": [
    {
      "version": "3.32.29",
      "claimed_by": "claude / STAK-315 vault images",
      "spec": "vault-image-upload",
      "issue": "STAK-315",
      "files_touched": ["js/vault.js", "js/image-cache.js"],
      "status": "implementing",
      "claimed_at": "2026-02-24T10:00:00Z",
      "expires_at": "2026-02-24T10:30:00Z"
    }
  ]
}
```

Fields:
- `version` — the version number you are claiming (matches your computed version)
- `claimed_by` — agent name + brief task description
- `spec` — spec folder name (e.g. `"vault-image-upload"`), or `null` if not spec-driven
- `issue` — Linear issue ID (e.g. `"STAK-315"`), or `null` if not issue-driven
- `files_touched` — list of files this agent will modify (enables conflict detection)
- `status` — one of `"queued"` → `"implementing"` → `"pr_open"` → `"done"`
- `claimed_at` / `expires_at` — ISO 8601 UTC timestamps; **30-minute TTL for hotfixes, 4-hour TTL for spec implementations**

The `version` becomes the **anchor** for all work: Linear notes, changelog bullets,
commit messages, and mem0 handoffs should all reference this version number.

### Step 5 — CREATE worktree + branch

```bash
git worktree add .claude/worktrees/patch-VERSION -b patch/VERSION
```

Example: `git worktree add .claude/worktrees/patch-3.32.29 -b patch/3.32.29`

The new branch is created off the current HEAD of `dev`.

### Step 6 — DO ALL WORK in the worktree

All file edits, the `/release patch` version bump, and test runs happen inside
`.claude/worktrees/patch-VERSION/`. Do not make changes to the main `dev` working tree
while your claim is held.

The `/release patch` skill reads `js/constants.js` relative to the worktree CWD, so
it correctly bumps to the claimed version.

### Step 7 — PUSH branch and open PR to dev

```bash
git push origin patch/VERSION
gh pr create --base dev --head patch/VERSION --draft \
  --title "patch/VERSION — description" \
  --body "..."
```

Cloudflare Pages will automatically generate a **preview URL** for this PR branch.
Use the preview URL to QA the changes before merging.

### Step 8 — QA the Cloudflare preview

Test the live preview URL generated by the PR. Confirm:
- The feature/fix works as expected
- No regressions in core flows
- Version number displays correctly in About modal

### Step 9 — MERGE to dev

When QA passes, merge the PR into `dev`. Use a squash merge for clean history,
or a regular merge to preserve individual commits — either is acceptable.

### Step 10 — CLEANUP

Remove your claim from the lock file **by version match** — do not delete the entire file,
as other agents may still hold active claims:

```bash
# Read the lock file, remove your claim entry, write back
# (If no other active claims remain, the file may be deleted or left as {"claims":[]})
```

Remove the worktree and branch:

```bash
git worktree remove .claude/worktrees/patch-VERSION --force
git branch -d patch/VERSION
```

If the remote branch is no longer needed:

```bash
git push origin --delete patch/VERSION
```

---

## Lock File Format

```json
{
  "claims": [
    {
      "version": "3.32.29",
      "claimed_by": "claude / STAK-315 vault images",
      "spec": "vault-image-upload",
      "issue": "STAK-315",
      "files_touched": ["js/vault.js", "js/image-cache.js"],
      "status": "implementing",
      "claimed_at": "2026-02-24T10:00:00Z",
      "expires_at": "2026-02-24T14:00:00Z"
    },
    {
      "version": "3.32.30",
      "claimed_by": "user / local hotfix",
      "spec": null,
      "issue": null,
      "files_touched": ["js/retail.js"],
      "status": "pr_open",
      "claimed_at": "2026-02-24T10:05:00Z",
      "expires_at": "2026-02-24T10:35:00Z"
    }
  ]
}
```

| Field | Description |
|-------|-------------|
| `version` | Version number being worked on (matches `APP_VERSION` bump target) |
| `claimed_by` | Agent name + brief task description (for human visibility) |
| `spec` | Spec folder name, or `null` if not spec-driven |
| `issue` | Linear issue ID, or `null` |
| `files_touched` | Files this agent will modify — enables conflict detection by other agents |
| `status` | `"queued"` → `"implementing"` → `"pr_open"` → `"done"` |
| `claimed_at` / `expires_at` | ISO 8601 UTC timestamps |

**TTL rules:**
- Hotfix (no spec): **30-minute TTL**
- Spec implementation: **4-hour TTL**
- Pre-assigned queued slot: **4-hour TTL**

Multiple agents can hold concurrent claims on **different** version numbers. No agent
ever takes over another agent's version — each claim is independently owned.

---

## TTL Rule

Claim TTL depends on work type:

| Work type | TTL | Refresh trigger |
|-----------|-----|-----------------|
| Hotfix (no spec) | **30 minutes** | Each commit |
| Spec implementation | **4 hours** | Each commit |
| Pre-assigned queued slot | **4 hours** | Agent activates slot |

An agent **refreshes** its own `expires_at` when it makes a commit (proves liveness):

```json
"expires_at": "<commit time + TTL>"
```

Healthy agents always release (remove their entry from the array) before TTL expires.

On any read, prune expired entries before computing the next available version.

If an agent's claim expires with no PR merged, the version is effectively skipped.
Minor gaps in the version sequence are acceptable.

---

## Parallel Agent Example

Agent A (STAK-315) and Agent B (hotfix) start at the same time:

1. Both read the lock → `claims: []`
2. Agent A computes `3.32.29`, writes claim → `claims: [{version: "3.32.29", ...}]`
3. Agent B reads again → sees `3.32.29` → computes `3.32.30`, appends → `claims: [{...29}, {...30}]`
4. Each creates its own worktree: `patch-3.32.29` and `patch-3.32.30`
5. Both work independently, push PRs, merge — no blocking, no TTL contention

---

## Integration with /dispatching-parallel-specs

When multiple specs are Phase 4-ready at once, use `/dispatching-parallel-specs` before
any agent claims a version. That skill:

1. Reads the current lock state and active claims
2. Finds all Phase 4-ready specs and extracts their file touch sets
3. Builds a conflict matrix (shared files, `js/constants.js`, `index.html`)
4. Produces a parallel/serial/handoff dispatch plan
5. Optionally pre-assigns version slots into the lock file (4-hour TTL, `status: "queued"`)

Agents activating a pre-assigned slot update `status` from `"queued"` to `"implementing"`.
Other agents see `files_touched` in the lock and can skip conflicting specs without starting.

---

## Integration with /release Skill

The `/release` skill (`.claude/skills/release/SKILL.md`) integrates this protocol in Phase 0:

- **Step 0a**: Read lock → prune expired claims → compute next version → append claim → create worktree
- **Step 0b**: Seed data sync (unchanged)
- **Phase 3 cleanup**: After PR merges, remove own claim entry from the array, remove worktree, delete branch

---

## Version Anchor Concept

Each version tag is an **anchor** for a batch of work:

- Version number is claimed *before* any code is written
- All Linear notes, changelog bullets, and mem0 handoffs reference that version
- The git tag (`v3.32.29`) is the permanent breadcrumb
- The PR body is assembled from all the patch tags between the last release and now

This means the version number is the *first* thing decided, not the last.

---

## Worktree Reference

```bash
# List active worktrees
git worktree list

# Remove a worktree (after merging)
git worktree remove .claude/worktrees/patch-3.32.29 --force

# If a worktree directory was deleted manually, prune stale metadata
git worktree prune
```

---

*Protocol established: 2026-02-22 | Worktree flow added: 2026-02-22 | Claims array: 2026-02-24*
